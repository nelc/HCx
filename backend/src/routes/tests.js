const express = require('express');
const { body, validationResult } = require('express-validator');
const db = require('../db');
const { authenticate, isTrainingOfficer, isEmployee } = require('../middleware/auth');

const router = express.Router();

// AI Question Generation endpoint
router.post('/generate-ai', authenticate, isTrainingOfficer, async (req, res) => {
  try {
    const { domain, title, description, skills, numberOfQuestions, questionTypes, level } = req.body;
    
    // Validate inputs
    if (!domain || !title || !numberOfQuestions || !questionTypes || questionTypes.length === 0 || !level) {
      return res.status(400).json({ error: 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø©' });
    }
    
    // Build a concise subject from domain and title ONLY
    // Ù…Ù„Ø§Ø­Ø¸Ø©: Ù„Ø§ Ù†Ø¶ÙŠÙ Ø§Ù„ÙˆØµÙ Ù‡Ù†Ø§ Ø­ØªÙ‰ Ù„Ø§ ÙŠØªÙ… ØªÙƒØ±Ø§Ø±Ù‡ Ø­Ø±ÙÙŠÙ‹Ø§ Ø¯Ø§Ø®Ù„ Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„
    let subject = '';
    if (domain && title) {
      subject = `${domain}: ${title}`;
    } else if (title) {
      subject = title;
    } else if (domain) {
      subject = domain;
    }
    
    // Add skills context
    let skillsText = '';
    if (skills && Array.isArray(skills) && skills.length > 0) {
      skillsText = skills.join('ØŒ ');
    }
    
    // Map level to Arabic for AI prompt
    const levelLabels = {
      'beginner': 'Ù…Ø¨ØªØ¯Ø¦',
      'intermediate': 'Ù…ØªÙˆØ³Ø·',
      'advanced': 'Ù…ØªÙ‚Ø¯Ù…',
      'mix': 'Ù…Ø²ÙŠØ¬ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª'
    };
    
    // Map question types to Arabic
    const typeLabels = {
      'mcq': 'Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯',
      'likert_scale': 'Ù…Ù‚ÙŠØ§Ø³ Ù„ÙŠÙƒØ±Øª',
      'self_rating': 'ØªÙ‚ÙŠÙŠÙ… Ø°Ø§ØªÙŠ',
      'open_text': 'Ù†Øµ Ù…ÙØªÙˆØ­'
    };
    
    const typesArabic = questionTypes.map(t => typeLabels[t] || t).join('ØŒ ');
    
    // Build the prompt for AI - Enhanced with Professional Assessment Methodology
    const systemPrompt = `Ø£Ù†Øª Ø®Ø¨ÙŠØ± Ù…ØªØ®ØµØµ ÙÙŠ ØªØµÙ…ÙŠÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ø§Ù„Ù…Ù‡Ù†ÙŠØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆØªØ·ÙˆÙŠØ± Ø§Ù„ÙƒÙØ§Ø¡Ø§Øª Ø§Ù„ÙˆØ¸ÙŠÙÙŠØ©. Ù…Ù‡Ù…ØªÙƒ Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ø§Ø­ØªØ±Ø§ÙÙŠØ© ØµØ§Ù„Ø­Ø© ØªÙ‚ÙŠØ³ Ø§Ù„Ù…Ø¹Ø±ÙØ© ÙˆØ§Ù„Ù…Ù‡Ø§Ø±Ø§Øª ÙˆØ§Ù„ÙƒÙØ§Ø¡Ø§Øª Ø¹Ø¨Ø± Ù…Ø®ØªÙ„Ù Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ø§Ù„ÙˆØ¸ÙŠÙÙŠØ©.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø¥Ø·Ø§Ø± ØªØµÙ…ÙŠÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… (ASSESSMENT DESIGN FRAMEWORK)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“‹ 1. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙƒÙØ§Ø¡Ø§Øª (Define Competencies):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ù…Ø­Ø¯Ø¯ØŒ Ø­Ø¯Ø¯:
â€¢ Ù…Ø¬Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªÙ‚ÙŠÙŠÙ…Ù‡Ø§
â€¢ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø­Ø±Ø¬Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ
â€¢ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ© Ù„Ù„ÙƒÙØ§Ø¡Ø©
â€¢ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ

ðŸ“Š 2. ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (Question Distribution):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ÙˆØ²Ù‘Ø¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:
â€¢ Ø§Ù„Ù…Ø¹Ø±ÙØ© (20-30%): Ø§Ù„Ø­Ù‚Ø§Ø¦Ù‚ ÙˆØ§Ù„Ù…ÙØ§Ù‡ÙŠÙ… ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª
â€¢ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ (40-50%): Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ù‚Ø§Ø¦Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª
â€¢ Ø§Ù„ØªØ­Ù„ÙŠÙ„/Ø§Ù„Ø­ÙƒÙ… (20-30%): Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª ÙˆØ§Ù„ØªÙ‚ÙŠÙŠÙ…

ðŸ§  3. Ù…Ø³ØªÙˆÙŠØ§Øª Ø¨Ù„ÙˆÙ… Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ© (Bloom's Taxonomy):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âŒ ØªØ¬Ù†Ø¨: Ø§Ù„Ø­ÙØ¸ ÙˆØ§Ù„ØªØ°ÙƒØ± Ø§Ù„Ø¨Ø³ÙŠØ· (Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªØ¹Ø±ÙŠÙØŸ)
âœ… Ø±ÙƒØ² Ø¹Ù„Ù‰:
  - Ø§Ù„ÙÙ‡Ù…: Ø´Ø±Ø­ Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø¨Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„Ù…ÙˆØ¸Ù Ø§Ù„Ø®Ø§Øµ
  - Ø§Ù„ØªØ·Ø¨ÙŠÙ‚: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¹Ø±ÙØ© ÙÙŠ Ù…ÙˆØ§Ù‚Ù Ø¬Ø¯ÙŠØ¯Ø©
  - Ø§Ù„ØªØ­Ù„ÙŠÙ„: ØªÙÙƒÙŠÙƒ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª ÙˆÙØ­Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  - Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: Ø¥ØµØ¯Ø§Ø± Ø£Ø­ÙƒØ§Ù… Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰ Ù…Ø¹Ø§ÙŠÙŠØ±
  - Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹: Ø§Ù‚ØªØ±Ø§Ø­ Ø­Ù„ÙˆÙ„ Ù…Ø¨ØªÙƒØ±Ø©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø¥Ø±Ø´Ø§Ø¯Ø§Øª Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (QUESTION TYPE GUIDELINES)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ”˜ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯ (Multiple Choice - MCQ):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¹Ø±ÙØ©ØŒ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§ØªØŒ Ø§Ù„Ø­ÙƒÙ… ÙÙŠ Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª
â€¢ ØªØ¶Ù…ÙŠÙ† 4 Ø®ÙŠØ§Ø±Ø§Øª Ù…Ø¹ Ù…Ø´ØªØªØ§Øª Ù…Ø¹Ù‚ÙˆÙ„Ø©
â€¢ ØªØ¬Ù†Ø¨ "ÙƒÙ„ Ù…Ø§ Ø³Ø¨Ù‚" Ø£Ùˆ "Ù„Ø§ Ø´ÙŠØ¡ Ù…Ù…Ø§ Ø³Ø¨Ù‚"
â€¢ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´ØªØªØ§Øª Ø¹Ù„Ù‰ Ø£Ø®Ø·Ø§Ø¡ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© Ø£Ùˆ Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø§Ù„Ø®Ø§Ø·Ø¦Ø©
â€¢ Ù…Ø«Ø§Ù„: "Ø£Ø¨Ù„Øº Ø¹Ù…ÙŠÙ„ Ø¹Ù† Ø§Ø®ØªØ±Ø§Ù‚ Ø¨ÙŠØ§Ù†Ø§Øª. Ù…Ø§ Ù‡Ùˆ Ø¥Ø¬Ø±Ø§Ø¤Ùƒ Ø§Ù„Ø£ÙˆÙ„ØŸ"

âš ï¸ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© Ù„Ù„Ø®ÙŠØ§Ø±Ø§Øª:
   â€¢ Ø§Ù„Ø£Ø±Ø¨Ø¹Ø© Ø®ÙŠØ§Ø±Ø§Øª ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…ØªØ³Ø§ÙˆÙŠØ© ÙÙŠ Ø§Ù„Ø¬ÙˆØ¯Ø© ÙˆØ§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
   â€¢ ÙƒÙ„ Ø®ÙŠØ§Ø± (ØµØ­ÙŠØ­ Ø£Ùˆ Ø®Ø§Ø·Ø¦) = Ø¬Ù…Ù„Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ ØªØ¨Ø±ÙŠØ± Ù…Ù†Ø·Ù‚ÙŠ
   â€¢ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ Ù„ÙŠØ³ "ÙˆØ§Ø¶Ø­Ø§Ù‹" - Ù‡Ùˆ Ø§Ù„Ø£ÙØ¶Ù„ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù…ÙŠÙ‚
   â€¢ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…ØºØ±ÙŠØ© Ø¬Ø¯Ø§Ù‹ ÙˆÙ…Ù†Ø·Ù‚ÙŠØ© Ù„Ù„Ø´Ø®Øµ Ø°ÙŠ Ø§Ù„ÙÙ‡Ù… Ø§Ù„Ø³Ø·Ø­ÙŠ
   â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ù…Ø´ØªØªØ§Øª Ø°ÙƒÙŠØ©: Ø®ÙŠØ§Ø±Ø§Øª ØµØ­ÙŠØ­Ø© Ø¬Ø²Ø¦ÙŠØ§Ù‹ Ø£Ùˆ Ù„Ù‡Ø§ Ø¹ÙŠÙˆØ¨ Ø®ÙÙŠØ© Ø£Ùˆ ØªØµÙ„Ø­ ÙÙŠ Ø³ÙŠØ§Ù‚ Ø¢Ø®Ø±

ðŸ“Š Ø£Ø³Ø¦Ù„Ø© Ù…Ù‚ÙŠØ§Ø³ Ù„ÙŠÙƒØ±Øª (Likert Scale):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø§Ù„Ù…ÙŠÙˆÙ„ Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ©ØŒ Ù…Ù…Ø§Ø±Ø³Ø§Øª Ø§Ù„Ø¹Ù…Ù„ØŒ Ø§Ù„Ù…ÙˆØ§Ù‚ÙØŒ ØªÙƒØ±Ø§Ø± Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
â€¢ Ù…Ù‚ÙŠØ§Ø³ 5 Ù†Ù‚Ø§Ø· Ù‚ÙŠØ§Ø³ÙŠ: Ù„Ø§ Ø£ÙˆØ§ÙÙ‚ Ø¨Ø´Ø¯Ø© â† Ø£ÙˆØ§ÙÙ‚ Ø¨Ø´Ø¯Ø©
â€¢ Ù…Ù‚ÙŠØ§Ø³ Ø§Ù„ØªÙƒØ±Ø§Ø±: Ø£Ø¨Ø¯Ø§Ù‹ â† Ø¯Ø§Ø¦Ù…Ø§Ù‹
â€¢ Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø¹Ø¨Ø§Ø±Ø§Øª ÙˆØ§Ø¶Ø­Ø© ÙˆÙ…Ø­Ø¯Ø¯Ø© ÙˆÙ‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ†ÙÙŠØ°
â€¢ Ù…Ø«Ø§Ù„: "Ø£ÙˆØ«Ù‚ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª ÙÙŠ Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø¨Ø§Ù†ØªØ¸Ø§Ù…"

â­ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°Ø§ØªÙŠ (Self-Assessment):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°Ø§ØªÙŠ Ù„Ù„ÙƒÙØ§Ø¡Ø©ØŒ Ø§Ù„Ø«Ù‚Ø© Ø¨Ø§Ù„Ù…Ù‡Ø§Ø±Ø§ØªØŒ Ø§Ø­ØªÙŠØ§Ø¬Ø§Øª Ø§Ù„ØªØ·ÙˆÙŠØ±
â€¢ Ù…Ù‚ÙŠØ§Ø³ Ø¥ØªÙ‚Ø§Ù† 5 Ù†Ù‚Ø§Ø·: Ù…Ø¨ØªØ¯Ø¦ â† Ø®Ø¨ÙŠØ±
â€¢ Ø£Ùˆ: Ù„Ø§ Ø®Ø¨Ø±Ø© â† ÙŠÙ…ÙƒÙ†Ù†ÙŠ ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
â€¢ ØªØ¶Ù…ÙŠÙ† Ù…Ø±ØªÙƒØ²Ø§Øª Ø³Ù„ÙˆÙƒÙŠØ© Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
â€¢ Ù…Ø«Ø§Ù„: "Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ Ø¥Ø¬Ø±Ø§Ø¡ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… SQL"

ðŸ“ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙØªÙˆØ­ (Open Text):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØŒ Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©ØŒ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ
â€¢ ØªÙˆÙÙŠØ± Ø³ÙŠØ§Ù‚ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ ÙˆØ§Ø¶Ø­
â€¢ ØªØ­Ø¯ÙŠØ¯ Ø·ÙˆÙ„ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
â€¢ ØªØ¶Ù…ÙŠÙ† Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
â€¢ Ù…Ø«Ø§Ù„: "ØµÙ ÙƒÙŠÙ Ø³ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ØµØ±Ø§Ø¹ Ø¨ÙŠÙ† Ø¹Ø¶ÙˆÙŠÙ† ÙÙŠ Ø§Ù„ÙØ±ÙŠÙ‚..."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ù…Ø¹Ø§ÙŠØ±Ø© Ø§Ù„ØµØ¹ÙˆØ¨Ø© (DIFFICULTY CALIBRATION)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“— Ù…Ø³ØªÙˆÙ‰ Ù…Ø¨ØªØ¯Ø¦ (Beginner):
â€¢ Ø£Ø³Ø¦Ù„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© ÙˆÙˆØ§Ø¶Ø­Ø©
â€¢ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª ÙˆØ§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
â€¢ Ø¥Ø¬Ø§Ø¨Ø§Øª ØµØ­ÙŠØ­Ø©/Ø®Ø§Ø·Ø¦Ø© ÙˆØ§Ø¶Ø­Ø©
â€¢ Ù…ÙˆØ§Ù‚Ù Ø¨ÙŠØ¦Ø© Ø¹Ù…Ù„ Ù…Ø£Ù„ÙˆÙØ©

ðŸ“™ Ù…Ø³ØªÙˆÙ‰ Ù…ØªÙˆØ³Ø· (Intermediate):
â€¢ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª ØªØ·Ø¨ÙŠÙ‚ÙŠØ© ØªØªØ·Ù„Ø¨ ØªØ­Ù„ÙŠÙ„Ø§Ù‹
â€¢ Ù…Ù†Ø§Ù‡Ø¬ Ù…ØªØ¹Ø¯Ø¯Ø© ØµØ§Ù„Ø­Ø© (ÙŠÙ„Ø²Ù… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª)
â€¢ Ø¯Ù…Ø¬ Ù…ÙØ§Ù‡ÙŠÙ… Ù…ØªØ¹Ø¯Ø¯Ø©
â€¢ ØªØ¹Ù‚ÙŠØ¯ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ

ðŸ“• Ù…Ø³ØªÙˆÙ‰ Ù…ØªÙ‚Ø¯Ù… (Advanced):
â€¢ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª ØºØ§Ù…Ø¶Ø© Ø£Ùˆ Ù…Ø¹Ù‚Ø¯Ø©
â€¢ Ø§ØªØ®Ø§Ø° Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
â€¢ Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª ØªØ­Øª Ø§Ù„Ù‚ÙŠÙˆØ¯
â€¢ Ø§Ù„ØªÙ†Ù‚Ù„ ÙÙŠ Ù…ÙˆØ§Ù‚Ù Ø¬Ø¯ÙŠØ¯Ø©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© Ù„Ù„ØªÙ‚ÙŠÙŠÙ… (ASSESSMENT METADATA)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ù„ÙƒÙ„ Ø³Ø¤Ø§Ù„ØŒ ÙŠØ¬Ø¨ ØªØ¶Ù…ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:

ðŸ“Œ Ù„Ù„Ø£Ø³Ø¦Ù„Ø© MCQ:
â€¢ rationale: Ø´Ø±Ø­ Ù„Ù…Ø§Ø°Ø§ Ù‡Ø°Ù‡ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
â€¢ common_errors: Ù…Ø§Ø°Ø§ ØªÙƒØ´Ù Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø© Ø¹Ù† ÙØ¬ÙˆØ§Øª Ø§Ù„Ù…Ø¹Ø±ÙØ©
â€¢ competency_measured: Ø§Ù„Ù…Ù‡Ø§Ø±Ø©/Ø§Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ø§Ù„ØªÙŠ ÙŠØªÙ… ØªÙ‚ÙŠÙŠÙ…Ù‡Ø§
â€¢ cognitive_level: Ù…Ø³ØªÙˆÙ‰ Ø¨Ù„ÙˆÙ… (knowledge/application/analysis)

ðŸ“Œ Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Likert/Self-Rating:
â€¢ competency_measured: Ø§Ù„Ø³Ù„ÙˆÙƒ Ø£Ùˆ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù…Ù‚Ø§Ø³Ø©
â€¢ cognitive_level: Ù†ÙˆØ¹ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…

ðŸ“Œ Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Open Text:
â€¢ rubric: Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø·
â€¢ competency_measured: Ù…Ø§ ÙŠØªÙ… ØªÙ‚ÙŠÙŠÙ…Ù‡
â€¢ cognitive_level: Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ø¬ÙˆØ¯Ø© (QUALITY STANDARDS)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Ù„ØºØ© ÙˆØ§Ø¶Ø­Ø© Ø®Ø§Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª (Ø¥Ù„Ø§ Ø¹Ù†Ø¯ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©)
âœ“ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª Ø°Ø§Øª ØµÙ„Ø© Ø¨Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„
âœ“ Ù…Ø­ØªÙˆÙ‰ Ù…Ø­Ø§ÙŠØ¯ Ø«Ù‚Ø§ÙÙŠØ§Ù‹
âœ“ Ø¢Ù„ÙŠØ§Øª ØªØºØ°ÙŠØ© Ø±Ø§Ø¬Ø¹Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ†ÙÙŠØ°
âœ“ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙˆØ¸ÙŠÙÙŠ
âœ“ ØªÙ…Ø«ÙŠÙ„ Ø¹Ø§Ø¯Ù„ Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„ÙƒÙØ§Ø¡Ø©
âœ“ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ

ØªØ¬Ù†Ø¨:
âœ— Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø®Ø§Ø¯Ø¹Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¶Ù„Ù„Ø©
âœ— Ø§Ù„Ù„ØºØ© Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø© Ø¨Ù„Ø§ Ø¯Ø§Ø¹Ù
âœ— Ø§Ù„ØªØ­ÙŠØ² Ø§Ù„Ø«Ù‚Ø§ÙÙŠ Ø£Ùˆ Ø§Ù„Ø¥Ù‚Ù„ÙŠÙ…ÙŠ
âœ— Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø°Ø§Øª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø© Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø© (Ø¥Ù„Ø§ Ø¥Ø°Ø§ Ù…Ø­Ø¯Ø¯)
âœ— Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª Ø£Ùˆ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
âœ— Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù†Ø¸Ø±ÙŠ Ø§Ù„Ù…Ù†ÙØµÙ„ Ø¹Ù† Ø§Ù„Ø¹Ù…Ù„

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
2. Ø£Ø³Ø¦Ù„Ø© MCQ: 4 Ø®ÙŠØ§Ø±Ø§Øª - ÙˆØ§Ø­Ø¯ ØµØ­ÙŠØ­ (is_correct: true, score: 10)
3. Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø§Ù„ØªØ§Ù… Ø¨Ø§Ù„Ø¹Ø¯Ø¯ ÙˆØ§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
4. ÙƒÙ„ Ø³Ø¤Ø§Ù„ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ‚ÙŠØ³ Ù…Ù‡Ø§Ø±Ø© Ù…Ø­Ø¯Ø¯Ø© Ù…Ù† Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©
5. Ù…Ù…Ù†ÙˆØ¹ Ø°ÙƒØ± Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø£Ùˆ Ø§Ø³Ù…Ù‡ ÙÙŠ Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„
6. Ù„Ø§ ØªÙ†Ø³Ø® Ø§Ù„ÙˆØµÙ Ø­Ø±ÙÙŠØ§Ù‹ - Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙƒÙ…Ø±Ø¬Ø¹ Ù„Ù„Ù…Ø­Ø§ÙˆØ±
7. ÙƒÙ„ Ø³Ø¤Ø§Ù„ ÙŠØªØ¶Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

Ø£Ø±Ø¬Ø¹ Ù…ØµÙÙˆÙØ© JSON ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ù†Øµ Ø¥Ø¶Ø§ÙÙŠ.`;

    // Calculate distribution of question types
    const typeDistribution = {};
    const questionsPerType = Math.floor(numberOfQuestions / questionTypes.length);
    const remainder = numberOfQuestions % questionTypes.length;
    
    questionTypes.forEach((type, index) => {
      typeDistribution[type] = questionsPerType + (index < remainder ? 1 : 0);
    });
    
    const distributionText = Object.entries(typeDistribution)
      .map(([type, count]) => `${count} ${typeLabels[type]}`)
      .join(' + ');

    const userPrompt = `Ù…Ø·Ù„ÙˆØ¨ ØªÙˆÙ„ÙŠØ¯ ${numberOfQuestions} Ø³Ø¤Ø§Ù„/Ø£Ø³Ø¦Ù„Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ø¹Ù…ÙŠÙ‚Ø© Ù„Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªØ§Ù„ÙŠ:

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙ‚ÙŠÙŠÙ… (ASSESSMENT INFO)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“‹ Ø§Ù„Ù…Ø¬Ø§Ù„: ${domain}
ðŸ“‹ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: ${title} (Ù„Ø§ ØªØ°ÙƒØ±Ù‡ ÙÙŠ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø£Ø¨Ø¯Ø§Ù‹)
ðŸ“‹ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø©: ${levelLabels[level]}
ðŸ“‹ Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù: Ù…ÙˆØ¸ÙÙˆÙ† ÙÙŠ Ù…Ø¬Ø§Ù„ ${domain}

${skillsText ? `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ© (TARGET COMPETENCIES)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸŽ“ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„ØªÙŠ ÙŠØ¬Ø¨ Ù‚ÙŠØ§Ø³Ù‡Ø§:
${skillsText}

âš ï¸ Ù…ØªØ·Ù„Ø¨ Ø¥Ù„Ø²Ø§Ù…ÙŠ: ÙƒÙ„ Ø³Ø¤Ø§Ù„ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ‚ÙŠØ³ Ø¨Ø¹Ù…Ù‚ ÙˆØ§Ø­Ø¯Ø© Ø£Ùˆ Ø£ÙƒØ«Ø± Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª
âš ï¸ Ø§Ø³ØªØ®Ø¯Ù… Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª ÙˆØ§Ù‚Ø¹ÙŠØ© ØªÙØ¸Ù‡Ø± ØªØ·Ø¨ÙŠÙ‚ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª ÙÙŠ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„
` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„Ø³ÙŠØ§Ù‚ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆØ± (CONTEXT & SCOPE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

${description || 'Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙˆØ§Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ø¹Ø§Ù… Ù„Ø¨Ù†Ø§Ø¡ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª ÙˆØ§Ù‚Ø¹ÙŠØ©'}

${description && description.length > 10 ? `
ðŸ’¡ Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„ÙˆØµÙ Ù„Ù€:
  â€¢ ÙÙ‡Ù… Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ù‡Ù†ÙŠ Ù„Ù„Ø£Ø³Ø¦Ù„Ø©
  â€¢ Ø¨Ù†Ø§Ø¡ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª ÙˆØ§Ù‚Ø¹ÙŠØ© Ø°Ø§Øª ØµÙ„Ø©
  â€¢ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆØ§Ù‚Ù ÙˆØ§Ù„ØªØ­Ø¯ÙŠØ§Øª Ø§Ù„ØªÙŠ ÙŠØ¬Ø¨ Ø§Ø®ØªØ¨Ø§Ø±Ù‡Ø§
  
âš ï¸ Ù„Ø§ ØªÙ†Ø³Ø® Ø§Ù„Ù†Øµ - Ø§Ø³ØªÙˆØ­Ù Ù…Ù†Ù‡ Ù„Ø¨Ù†Ø§Ø¡ Ø­Ø§Ù„Ø§Øª Ø¯Ø±Ø§Ø³ÙŠØ© ÙˆÙ…ÙˆØ§Ù‚Ù Ø¹Ù…Ù„ÙŠØ©
` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø© (DIFFICULTY LEVEL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

${level === 'beginner' ? `
ðŸ“— Ù…Ø³ØªÙˆÙ‰ Ù…Ø¨ØªØ¯Ø¦:
â€¢ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª ÙˆØ§Ø¶Ø­Ø© ÙˆÙ…Ø¨Ø§Ø´Ø±Ø© Ù„ÙƒÙ† Ù„ÙŠØ³Øª Ø³Ø·Ø­ÙŠØ©
â€¢ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø¨Ø§Ø¯Ø¦ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙÙŠ Ù…ÙˆØ§Ù‚Ù Ø¹Ù…Ù„ Ø¨Ø³ÙŠØ·Ø©
â€¢ Ø£Ø³Ø¦Ù„Ø© ØªÙ‚ÙŠØ³ Ø§Ù„ÙÙ‡Ù… ÙˆØ§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ„ÙŠØŒ Ù„ÙŠØ³ Ø§Ù„Ø­ÙØ¸
â€¢ cognitive_level Ù„Ù„Ø£Ø³Ø¦Ù„Ø©: "knowledge" Ø£Ùˆ "application"
` : ''}${level === 'intermediate' ? `
ðŸ“™ Ù…Ø³ØªÙˆÙ‰ Ù…ØªÙˆØ³Ø·:
â€¢ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ØªØ­ØªØ§Ø¬ ØªØ­Ù„ÙŠÙ„
â€¢ Ø¯Ù…Ø¬ Ø¹Ø¯Ø© Ù…ÙØ§Ù‡ÙŠÙ… Ø£Ùˆ Ù…Ù‡Ø§Ø±Ø§Øª ÙÙŠ Ù…ÙˆÙ‚Ù ÙˆØ§Ø­Ø¯
â€¢ Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨ÙŠÙ† Ø®ÙŠØ§Ø±Ø§Øª ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ÙØ¶Ù„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø§ÙŠÙŠØ±
â€¢ cognitive_level Ù„Ù„Ø£Ø³Ø¦Ù„Ø©: "application" Ø£Ùˆ "analysis"
` : ''}${level === 'advanced' ? `
ðŸ“• Ù…Ø³ØªÙˆÙ‰ Ù…ØªÙ‚Ø¯Ù…:
â€¢ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª Ù…Ø¹Ù‚Ø¯Ø© Ø°Ø§Øª Ù…ØªØºÙŠØ±Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© ÙˆÙ…ØªØ´Ø§Ø¨ÙƒØ©
â€¢ Ù…Ø´ÙƒÙ„Ø§Øª ØºÙŠØ± Ù†Ù…Ø·ÙŠØ© ØªØªØ·Ù„Ø¨ ØªÙÙƒÙŠØ± Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ
â€¢ ØªÙ‚ÙŠÙŠÙ… Ø´Ø§Ù…Ù„ Ù„Ù„Ø¨Ø¯Ø§Ø¦Ù„ Ù…Ø¹ Ø§Ù„ØªØ¨Ø±ÙŠØ±
â€¢ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®Ø§Ø·Ø± ÙˆØ§Ù„ÙÙˆØ§Ø¦Ø¯ ÙˆØ§Ù„Ø¢Ø«Ø§Ø± Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ù…Ø¯Ù‰
â€¢ cognitive_level Ù„Ù„Ø£Ø³Ø¦Ù„Ø©: "analysis" Ø£Ùˆ "evaluation"
` : ''}${level === 'mix' ? `
ðŸ“š Ù…Ø³ØªÙˆÙ‰ Ù…Ø®ØªÙ„Ø·:
â€¢ ÙˆØ²Ù‘Ø¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø«Ù„Ø§Ø«Ø©
â€¢ Ø«Ù„Ø« Ø§Ù„Ø£Ø³Ø¦Ù„Ø©: Ù…Ø¨ØªØ¯Ø¦ (cognitive_level: "knowledge")
â€¢ Ø«Ù„Ø« Ø§Ù„Ø£Ø³Ø¦Ù„Ø©: Ù…ØªÙˆØ³Ø· (cognitive_level: "application")
â€¢ Ø«Ù„Ø« Ø§Ù„Ø£Ø³Ø¦Ù„Ø©: Ù…ØªÙ‚Ø¯Ù… (cognitive_level: "analysis")
` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„ØµØ§Ø±Ù…Ø© (STRICT REQUIREMENTS)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£ Ø§Ù„Ø¹Ø¯Ø¯ ÙˆØ§Ù„ØªÙˆØ²ÙŠØ¹:
   â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©: ${numberOfQuestions} Ø¨Ø§Ù„Ø¶Ø¨Ø·
   â€¢ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹: ${distributionText}

2ï¸âƒ£ Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰:
   ${skillsText ? `â€¢ ÙƒÙ„ Ø³Ø¤Ø§Ù„ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ‚ÙŠØ³ Ù…Ù‡Ø§Ø±Ø© Ù…Ø­Ø¯Ø¯Ø© Ù…Ù†: ${skillsText}` : ''}
   â€¢ ÙƒÙ„ Ø³Ø¤Ø§Ù„ = Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ ÙˆØ§Ù‚Ø¹ÙŠ + Ø³Ø¤Ø§Ù„ ØªØ­Ù„ÙŠÙ„ÙŠ Ø¹Ù…ÙŠÙ‚
   â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø­Ø§Ù„Ø§Øª Ø¯Ø±Ø§Ø³ÙŠØ© ÙˆÙ…ÙˆØ§Ù‚Ù Ø¹Ù…Ù„ Ø­Ù‚ÙŠÙ‚ÙŠØ©

3ï¸âƒ£ Ø£Ø³Ø¦Ù„Ø© MCQ - Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:
   â€¢ 4 Ø®ÙŠØ§Ø±Ø§Øª Ù…ØªØ³Ø§ÙˆÙŠØ© ÙÙŠ Ø§Ù„Ø¬ÙˆØ¯Ø© ÙˆØ§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
   â€¢ Ø§Ù„Ù…Ø´ØªØªØ§Øª Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰ Ø£Ø®Ø·Ø§Ø¡ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
   â€¢ ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·: is_correct: true, score: 10
   â€¢ Ø§Ù„Ø¨Ø§Ù‚ÙŠ: is_correct: false, score: 0

4ï¸âƒ£ Ù…Ù…Ù†ÙˆØ¹Ø§Øª Ù…Ø·Ù„Ù‚Ø©:
   âŒ Ø°ÙƒØ± Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙ‚ÙŠÙŠÙ… ÙÙŠ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
   âŒ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø³Ø·Ø­ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ø¬Ø¯Ø§Ù‹
   âŒ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø³Ø®ÙŠÙØ© Ø£Ùˆ Ø§Ù„ÙˆØ§Ø¶Ø­ Ø®Ø·Ø¤Ù‡Ø§

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (JSON FORMAT)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[
  {
    "question_type": "mcq",
    "question_ar": "ÙÙŠ Ù…Ø¤Ø³Ø³Ø© ØªØ¹Ø§Ù†ÙŠ Ù…Ù† [Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ ÙˆØ§Ù‚Ø¹ÙŠ Ù…ÙØµÙ„ Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù… ÙˆØ³ÙŠØ§Ù‚]ØŒ Ù‚Ø§Ù… ÙØ±ÙŠÙ‚ [Ø§Ø³Ù… Ø§Ù„ÙØ±ÙŠÙ‚] Ø¨Ù€ [Ù…ÙˆÙ‚Ù ÙˆØªØ­Ù„ÙŠÙ„]. Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª Ø§Ù„Ù…Ù‡Ù†ÙŠØ© ÙˆØ§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©ØŒ Ø£ÙŠ Ù…Ù† Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© ÙŠØ­Ù‚Ù‚ Ø£ÙØ¶Ù„ ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† [Ø¹Ø§Ù…Ù„ 1] Ùˆ[Ø¹Ø§Ù…Ù„ 2]ØŸ",
    "options": [
      {"value": "a", "text_ar": "ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© X Ù…Ø¹ YØŒ Ù…Ù…Ø§ ÙŠØ¹Ø§Ù„Ø¬ Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠ ÙˆÙŠÙˆÙØ± Ø­Ù…Ø§ÙŠØ© Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ù…Ø¯Ù‰ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„Ù…Ø§Ù„ÙŠØ© ÙˆØ§Ù„Ø²Ù…Ù†ÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ÙÙŠ Ø§Ù„Ø³ÙŠØ§Ù‚", "is_correct": true, "score": 10},
      {"value": "b", "text_ar": "ØªÙ†ÙÙŠØ° Ø­Ù„ Z Ø§Ù„Ø³Ø±ÙŠØ¹ØŒ ÙˆÙ‡Ùˆ ÙØ¹Ø§Ù„ Ù…Ù† Ø­ÙŠØ« Ø§Ù„ØªÙƒÙ„ÙØ© ÙˆÙ…Ø¬Ø±Ø¨ ÙÙŠ Ù…Ø¤Ø³Ø³Ø§Øª Ù…Ø´Ø§Ø¨Ù‡Ø©ØŒ Ù„ÙƒÙ†Ù‡ ÙŠØ¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø¹Ø±Ø§Ø¶ Ø§Ù„Ø¸Ø§Ù‡Ø±Ø© Ø¯ÙˆÙ† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠØ© Ù„Ù„Ù…Ø´ÙƒÙ„Ø©", "is_correct": false, "score": 0},
      {"value": "c", "text_ar": "Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ø­Ù„ Ø§Ù„Ø´Ø§Ù…Ù„ W Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚ Ù„Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ø¯ÙˆÙ„ÙŠØ©ØŒ ÙˆÙ‡Ùˆ Ù…Ø«Ø§Ù„ÙŠ Ù†Ø¸Ø±ÙŠØ§Ù‹ Ù„ÙƒÙ† Ù…Ø¹Ù‚Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ° ÙˆÙŠØªØ·Ù„Ø¨ Ù…ÙˆØ§Ø±Ø¯ ØªØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…ÙŠØ²Ø§Ù†ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©", "is_correct": false, "score": 0},
      {"value": "d", "text_ar": "ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ù†Ù‡Ø¬ÙŠØ© Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ© Ø§Ù„Ù…Ø¬Ø±Ø¨Ø© VØŒ ÙˆÙ‡ÙŠ Ø¢Ù…Ù†Ø© ÙˆÙ…ÙˆØ«ÙˆÙ‚Ø© Ù„ÙƒÙ†Ù‡Ø§ Ù„Ø§ ØªØ£Ø®Ø° ÙÙŠ Ø§Ù„Ø§Ø¹ØªØ¨Ø§Ø± Ø§Ù„ØªØ·ÙˆØ±Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø© ÙˆØ§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„ØªÙ‚Ù†ÙŠØ©", "is_correct": false, "score": 0}
    ],
    "assessment_metadata": {
      "rationale": "Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Ø£) ØµØ­ÙŠØ­Ø© Ù„Ø£Ù†Ù‡Ø§ ØªØ¬Ù…Ø¹ Ø¨ÙŠÙ† Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠ ÙˆØ§Ù„Ø­Ù…Ø§ÙŠØ© Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ù…Ø¯Ù‰ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù„Ù„Ù…Ø¤Ø³Ø³Ø©",
      "common_errors": "Ø§Ø®ØªÙŠØ§Ø± (Ø¨) ÙŠØ¯Ù„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹Ø© Ø¯ÙˆÙ† Ø§Ù„Ù†Ø¸Ø± Ù„Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠØ©. Ø§Ø®ØªÙŠØ§Ø± (Ø¬) ÙŠØ¯Ù„ Ø¹Ù„Ù‰ Ø¹Ø¯Ù… Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. Ø§Ø®ØªÙŠØ§Ø± (Ø¯) ÙŠØ¯Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ù„Ù„ØªØºÙŠÙŠØ±",
      "competency_measured": "Ø§Ù„Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª ÙˆØ§ØªØ®Ø§Ø° Ù‚Ø±Ø§Ø±Ø§Øª Ù…ØªÙˆØ§Ø²Ù†Ø© ØªØ±Ø§Ø¹ÙŠ Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©",
      "cognitive_level": "analysis"
    }
  },
  {
    "question_type": "likert_scale",
    "question_ar": "Ø¹Ù†Ø¯ Ù…ÙˆØ§Ø¬Ù‡Ø© [Ù…ÙˆÙ‚Ù Ù…Ø­Ø¯Ø¯]ØŒ Ø£Ù‚ÙˆÙ… Ø¨Ù€ [Ø³Ù„ÙˆÙƒ/Ù…Ù…Ø§Ø±Ø³Ø© Ù…Ø­Ø¯Ø¯Ø©] Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… [Ù…Ù†Ù‡Ø¬ÙŠØ©/Ø£Ø¯Ø§Ø©]",
    "assessment_metadata": {
      "competency_measured": "Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø© Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ© Ø§Ù„Ù…Ù‚Ø§Ø³Ø©",
      "cognitive_level": "self_assessment"
    }
  },
  {
    "question_type": "self_rating",
    "question_ar": "Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ [Ù…Ù‡Ø§Ø±Ø© Ù…Ø­Ø¯Ø¯Ø© Ø¬Ø¯Ø§Ù‹] ÙÙŠ Ø³ÙŠØ§Ù‚ [Ø¨ÙŠØ¦Ø© Ø¹Ù…Ù„ Ù…Ø­Ø¯Ø¯Ø©] Ù…Ø¹ [Ù‚ÙŠÙˆØ¯ Ø£Ùˆ Ù…ØªØ·Ù„Ø¨Ø§Øª]",
    "assessment_metadata": {
      "competency_measured": "Ø§Ù„Ù…Ù‡Ø§Ø±Ø© Ø£Ùˆ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù…Ù‚Ø§Ø³Ø©",
      "cognitive_level": "self_assessment"
    }
  },
  {
    "question_type": "open_text",
    "question_ar": "ÙˆØ§Ø¬Ù‡Øª [Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ù…Ø¹Ù‚Ø¯]. Ø­Ù„Ù„ [Ø¬Ø§Ù†Ø¨ Ù…Ø¹ÙŠÙ†] ÙˆØ§Ù‚ØªØ±Ø­ [Ù…Ø·Ù„ÙˆØ¨ Ù…Ø­Ø¯Ø¯] Ù…Ø¹ ØªØ¨Ø±ÙŠØ± ÙƒÙ„ Ù‚Ø±Ø§Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ [Ù…Ø¹Ø§ÙŠÙŠØ±]",
    "assessment_metadata": {
      "rubric": [
        {"criterion": "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©", "points": 3, "description": "ØªØ­Ø¯ÙŠØ¯ ÙˆØ§Ø¶Ø­ Ù„Ù„Ù…Ø´ÙƒÙ„Ø© ÙˆØ£Ø³Ø¨Ø§Ø¨Ù‡Ø§ Ø§Ù„Ø¬Ø°Ø±ÙŠØ©"},
        {"criterion": "Ø¬ÙˆØ¯Ø© Ø§Ù„Ø­Ù„ Ø§Ù„Ù…Ù‚ØªØ±Ø­", "points": 4, "description": "Ø­Ù„ Ø¹Ù…Ù„ÙŠ ÙˆÙ…Ø¨ØªÙƒØ± ÙŠØ±Ø§Ø¹ÙŠ Ø§Ù„Ù‚ÙŠÙˆØ¯"},
        {"criterion": "Ø§Ù„ØªØ¨Ø±ÙŠØ± Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠ", "points": 3, "description": "ØªØ¨Ø±ÙŠØ± ÙˆØ§Ø¶Ø­ Ù„ÙƒÙ„ Ù‚Ø±Ø§Ø± Ù…Ø¹ Ø£Ø¯Ù„Ø©"}
      ],
      "competency_measured": "Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ ÙˆØ­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©",
      "cognitive_level": "evaluation"
    }
  }
]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ø§Ù„ØªØ°ÙƒÙŠØ±Ø§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ ÙƒÙ„ Ø³Ø¤Ø§Ù„ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù† Ø­Ù‚Ù„ assessment_metadata
âœ“ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù„Ù„Ø£Ø³Ø¦Ù„Ø© = ${numberOfQuestions} Ø¨Ø§Ù„Ø¶Ø¨Ø·
âœ“ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ø­Ø¯Ø¯: ${distributionText}
âœ“ Ù„Ø£Ø³Ø¦Ù„Ø© MCQ: 4 Ø®ÙŠØ§Ø±Ø§Øª Ø¨Ø§Ù„Ø¶Ø¨Ø· Ù…Ø¹ text_ar ÙˆØ§Ø¶Ø­ Ù„ÙƒÙ„ Ø®ÙŠØ§Ø±
âœ“ cognitive_level: Ø£Ø­Ø¯ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ØªØ§Ù„ÙŠØ©: "knowledge", "application", "analysis", "evaluation", "self_assessment"

Ø£Ø±Ø¬Ø¹ ÙÙ‚Ø· Ù…ØµÙÙˆÙØ© JSON ØµØ§Ù„Ø­Ø© Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ù†Øµ Ù‚Ø¨Ù„Ù‡Ø§ Ø£Ùˆ Ø¨Ø¹Ø¯Ù‡Ø§.`;

    // Try to use OpenAI API if configured
    const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
    
    if (!OPENAI_API_KEY) {
      // Fallback: Generate sample questions without AI
      const generatedQuestions = generateSampleQuestions(subject, numberOfQuestions, questionTypes, level, domain, title, description, skills);
      return res.json({ questions: generatedQuestions });
    }

    // Call OpenAI API using the official SDK
    const OpenAI = require('openai');
    const openai = new OpenAI({ apiKey: OPENAI_API_KEY });
    
    let content;
    try {
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.7,
        max_tokens: 4000
      });
      
      content = completion.choices[0].message.content;
    } catch (apiError) {
      console.error('OpenAI API error:', apiError);
      // Fallback to sample questions
      const generatedQuestions = generateSampleQuestions(subject, numberOfQuestions, questionTypes, level, domain, title, description, skills);
      return res.json({ questions: generatedQuestions });
    }
    
    // Log raw AI response for debugging
    console.log('Raw AI Response:', content);
    
    // Parse the JSON from the response
    let questions;
    try {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        questions = JSON.parse(jsonMatch[0]);
      } else {
        questions = JSON.parse(content);
      }
      
      // Log parsed questions
      console.log('Parsed AI Questions:', JSON.stringify(questions, null, 2));
      
      // Validate the AI response meets requirements
      const validationErrors = [];
      
      // Check exact number of questions
      if (questions.length !== numberOfQuestions) {
        validationErrors.push(`Expected ${numberOfQuestions} questions but got ${questions.length}`);
      }
      
      // Check question types distribution
      const actualTypeCount = {};
      questionTypes.forEach(type => {
        actualTypeCount[type] = questions.filter(q => q.question_type === type).length;
      });
      
      const expectedTypeCount = {};
      const questionsPerType = Math.floor(numberOfQuestions / questionTypes.length);
      const remainder = numberOfQuestions % questionTypes.length;
      questionTypes.forEach((type, index) => {
        expectedTypeCount[type] = questionsPerType + (index < remainder ? 1 : 0);
      });
      
      questionTypes.forEach(type => {
        if (actualTypeCount[type] !== expectedTypeCount[type]) {
          validationErrors.push(`Expected ${expectedTypeCount[type]} questions of type "${type}" but got ${actualTypeCount[type]}`);
        }
      });
      
      // Check all questions have required fields
      questions.forEach((q, idx) => {
        if (!q.question_ar || q.question_ar.trim() === '') {
          validationErrors.push(`Question ${idx + 1} is missing question_ar`);
        }
        if (!q.question_type || !['mcq', 'likert_scale', 'self_rating', 'open_text'].includes(q.question_type)) {
          validationErrors.push(`Question ${idx + 1} has invalid question_type: ${q.question_type}`);
        }
        // Validate MCQ has proper options
        if (q.question_type === 'mcq') {
          if (!q.options || !Array.isArray(q.options) || q.options.length < 2) {
            validationErrors.push(`Question ${idx + 1} (MCQ) must have at least 2 options`);
          } else {
            const hasCorrectAnswer = q.options.some(opt => opt.is_correct === true);
            if (!hasCorrectAnswer) {
              validationErrors.push(`Question ${idx + 1} (MCQ) must have at least one correct answer`);
            }
            // Check all options have text_ar
            q.options.forEach((opt, optIdx) => {
              if (!opt.text_ar || opt.text_ar.trim() === '') {
                validationErrors.push(`Question ${idx + 1} option ${optIdx + 1} is missing text_ar`);
              }
            });
          }
        }
      });
      
      // If validation fails, use fallback
      if (validationErrors.length > 0) {
        console.error('AI Response Validation Failed:', validationErrors);
        console.log('Using fallback generation instead');
        const generatedQuestions = generateSampleQuestions(subject, numberOfQuestions, questionTypes, level, domain, title, description, skills);
        return res.json({ questions: generatedQuestions });
      }
      
    } catch (parseError) {
      console.error('Failed to parse AI response:', parseError);
      console.error('Content was:', content);
      // Fallback to sample questions
      const generatedQuestions = generateSampleQuestions(subject, numberOfQuestions, questionTypes, level, domain, title, description, skills);
      return res.json({ questions: generatedQuestions });
    }
    
    // Format questions for the frontend
    const formattedQuestions = questions.map((q, index) => {
      // Properly format MCQ options ensuring text_ar is correctly set
      let formattedOptions = null;
      if (q.question_type === 'mcq' && q.options && Array.isArray(q.options)) {
        formattedOptions = q.options.map((opt, optIdx) => {
          // Handle different possible field names from AI
          const optionText = opt.text_ar || opt.text || opt.option || opt.content || opt.answer || '';
          return {
            value: opt.value || String.fromCharCode(97 + optIdx), // a, b, c, d
            text_ar: optionText,
            text_en: opt.text_en || '',
            is_correct: opt.is_correct === true || opt.correct === true || opt.isCorrect === true,
            score: opt.is_correct === true || opt.correct === true || opt.isCorrect === true ? 10 : (opt.score || 0)
          };
        });
      } else if (q.question_type === 'mcq') {
        // No options provided, create empty placeholders
        formattedOptions = [
          { value: 'a', text_ar: '', text_en: '', is_correct: false, score: 0 },
          { value: 'b', text_ar: '', text_en: '', is_correct: false, score: 0 },
          { value: 'c', text_ar: '', text_en: '', is_correct: false, score: 0 },
          { value: 'd', text_ar: '', text_en: '', is_correct: false, score: 0 },
        ];
      }

      // Extract and format assessment metadata
      const metadata = q.assessment_metadata || {};
      const assessmentMetadata = {
        rationale: metadata.rationale || null,
        common_errors: metadata.common_errors || null,
        competency_measured: metadata.competency_measured || null,
        cognitive_level: metadata.cognitive_level || 'application',
        rubric: metadata.rubric || null
      };

      return {
        id: `ai-${Date.now()}-${index}`,
        question_type: q.question_type,
        question_ar: q.question_ar || q.question || '',
        question_en: q.question_en || '',
        skill_id: '',
        required: true,
        weight: 1.0,
        options: formattedOptions,
        likert_labels: q.question_type === 'likert_scale' ? {
          min_label_ar: 'Ù„Ø§ Ø£ÙˆØ§ÙÙ‚ Ø¨Ø´Ø¯Ø©',
          min_label_en: 'Strongly Disagree',
          max_label_ar: 'Ø£ÙˆØ§ÙÙ‚ Ø¨Ø´Ø¯Ø©',
          max_label_en: 'Strongly Agree',
          scale: 5
        } : null,
        self_rating_config: q.question_type === 'self_rating' ? {
          min: 1, max: 10,
          labels: [
            { value: 1, ar: 'Ù…Ø¨ØªØ¯Ø¦', en: 'Beginner' },
            { value: 5, ar: 'Ù…ØªÙˆØ³Ø·', en: 'Intermediate' },
            { value: 10, ar: 'Ø®Ø¨ÙŠØ±', en: 'Expert' }
          ]
        } : null,
        assessment_metadata: assessmentMetadata,
      };
    });
    
    // Log for debugging
    console.log('AI Generated Questions:', JSON.stringify(formattedQuestions, null, 2));
    
    res.json({ questions: formattedQuestions });
  } catch (error) {
    console.error('AI generation error:', error);
    res.status(500).json({ error: 'ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©' });
  }
});

// Fallback function to generate sample questions without AI
function generateSampleQuestions(subject, numberOfQuestions, questionTypes, level, domain = '', title = '', description = '', skills = []) {
  // PRIORITY 1: Use skills if available (this is the scope)
  // PRIORITY 2: Use domain
  // PRIORITY 3: Use default
  // NOTE: Never use the test title to prevent it from appearing in questions
  
  let skillsList = [];
  if (skills && Array.isArray(skills) && skills.length > 0) {
    skillsList = skills;
    subject = skills[0]; // Use first skill as primary subject
  } else if (!subject && domain) {
    subject = domain;
  } else if (!subject) {
    subject = 'Ø§Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ù…Ø­Ø¯Ø¯';
  }
  
  console.log('Fallback generation - Skills:', skillsList);
  console.log('Fallback generation - Primary subject:', subject);
  const questions = [];
  const numQuestions = parseInt(numberOfQuestions) || 5;
  
  // Calculate strict distribution
  const questionsPerType = Math.floor(numQuestions / questionTypes.length);
  const remainder = numQuestions % questionTypes.length;
  const typeDistribution = {};
  
  questionTypes.forEach((type, index) => {
    typeDistribution[type] = questionsPerType + (index < remainder ? 1 : 0);
  });
  
  console.log('Fallback generation - Distribution:', typeDistribution);
  
  // MCQ question templates with real options
  const mcqTemplates = [
    {
      question: `Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªØ¹Ø±ÙŠÙ Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù€ ${subject}ØŸ`,
      options: [
        { text_ar: `Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ù…Ø¨Ø§Ø¯Ø¦ ÙˆØ§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ ${subject}`, is_correct: true },
        { text_ar: `Ù†Ø¸Ø±ÙŠØ© Ù‚Ø¯ÙŠÙ…Ø© Ù„Ù… ØªØ¹Ø¯ ØªØ³ØªØ®Ø¯Ù… ÙÙŠ ${subject}`, is_correct: false },
        { text_ar: `Ù…ØµØ·Ù„Ø­ ØºÙŠØ± Ø¹Ù„Ù…ÙŠ ÙŠØ³ØªØ®Ø¯Ù… ÙÙŠ ${subject}`, is_correct: false },
        { text_ar: `ØªÙ‚Ù†ÙŠØ© Ø­Ø¯ÙŠØ«Ø© Ù„Ø§ Ø¹Ù„Ø§Ù‚Ø© Ù„Ù‡Ø§ Ø¨Ù€ ${subject}`, is_correct: false },
      ]
    },
    {
      question: `Ø£ÙŠ Ù…Ù† Ø§Ù„ØªØ§Ù„ÙŠ ÙŠØ¹ØªØ¨Ø± Ù…Ù† Ø£Ù‡Ù… Ø¹Ù†Ø§ØµØ± ${subject}ØŸ`,
      options: [
        { text_ar: `Ø§Ù„ØªØ®Ø·ÙŠØ· ÙˆØ§Ù„ØªÙ†Ø¸ÙŠÙ… Ø§Ù„ÙØ¹Ø§Ù„`, is_correct: true },
        { text_ar: `Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ÙÙŠ Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª`, is_correct: false },
        { text_ar: `ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ù…Ù‡Ù†ÙŠØ©`, is_correct: false },
        { text_ar: `Ø¹Ø¯Ù… Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙˆØ§Ù„ØªÙ‚ÙŠÙŠÙ…`, is_correct: false },
      ]
    },
    {
      question: `Ù…Ø§ Ù‡ÙŠ Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª ÙÙŠ Ù…Ø¬Ø§Ù„ ${subject}ØŸ`,
      options: [
        { text_ar: `Ø§ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ù…Ù‡Ù†ÙŠØ© ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³ØªÙ…Ø±`, is_correct: true },
        { text_ar: `Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø¨Ø±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ© ÙÙ‚Ø·`, is_correct: false },
        { text_ar: `ØªØ¬Ù†Ø¨ Ø§Ù„ØªØºÙŠÙŠØ± ÙˆØ§Ù„ØªØ·ÙˆÙŠØ±`, is_correct: false },
        { text_ar: `Ø§Ù„Ø¹Ù…Ù„ Ø¨Ù…Ø¹Ø²Ù„ Ø¹Ù† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†`, is_correct: false },
      ]
    },
    {
      question: `ÙƒÙŠÙ ÙŠÙ…ÙƒÙ† Ù‚ÙŠØ§Ø³ Ø§Ù„Ù†Ø¬Ø§Ø­ ÙÙŠ ${subject}ØŸ`,
      options: [
        { text_ar: `Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ù„Ù…ÙˆØ³Ø©`, is_correct: true },
        { text_ar: `Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ù†Ø·Ø¨Ø§Ø¹Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© ÙÙ‚Ø·`, is_correct: false },
        { text_ar: `Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚ÙŠØ§Ø³ Ø§Ù„Ù†Ø¬Ø§Ø­ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø¬Ø§Ù„`, is_correct: false },
        { text_ar: `Ù…Ù† Ø®Ù„Ø§Ù„ Ø¹Ø¯Ø¯ Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø¹Ù…Ù„ ÙÙ‚Ø·`, is_correct: false },
      ]
    },
    {
      question: `Ù…Ø§ Ù‡Ùˆ Ø¯ÙˆØ± Ø§Ù„ØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§ ÙÙŠ ØªØ·ÙˆÙŠØ± ${subject}ØŸ`,
      options: [
        { text_ar: `ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙƒÙØ§Ø¡Ø© ÙˆØ£ØªÙ…ØªØ© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª`, is_correct: true },
        { text_ar: `Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¯ÙˆØ± Ù„Ù„ØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§`, is_correct: false },
        { text_ar: `Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ Ø¯ÙˆÙ† ÙØ§Ø¦Ø¯Ø©`, is_correct: false },
        { text_ar: `Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø¨Ø´Ø±ÙŠ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„`, is_correct: false },
      ]
    },
    {
      question: `Ù…Ø§ Ù‡ÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙÙŠ ${subject}ØŸ`,
      options: [
        { text_ar: `Ù…ÙˆØ§ÙƒØ¨Ø© Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙˆØªØ·ÙˆÙŠØ± Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø±`, is_correct: true },
        { text_ar: `Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ§Øª ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø¬Ø§Ù„`, is_correct: false },
        { text_ar: `Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª ØªÙ‚ØªØµØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ù…Ø§Ù„ÙŠ ÙÙ‚Ø·`, is_correct: false },
        { text_ar: `Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØºÙ„Ø¨ Ø¹Ù„ÙŠÙ‡Ø§`, is_correct: false },
      ]
    },
    {
      question: `Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ ${subject}ØŸ`,
      options: [
        { text_ar: `Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„ØªØ­Ù„ÙŠÙ„ÙŠ ÙˆØ§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„ÙØ¹Ø§Ù„ ÙˆØ­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª`, is_correct: true },
        { text_ar: `Ø§Ù„Ø­ÙØ¸ ÙÙ‚Ø· Ø¯ÙˆÙ† ÙÙ‡Ù…`, is_correct: false },
        { text_ar: `Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ø±Ø§Øª Ù…Ø­Ø¯Ø¯Ø© Ù…Ø·Ù„ÙˆØ¨Ø©`, is_correct: false },
        { text_ar: `Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ© ÙÙ‚Ø· Ø¯ÙˆÙ† Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©`, is_correct: false },
      ]
    },
    {
      question: `ÙƒÙŠÙ ÙŠÙ…ÙƒÙ† ØªØ·ÙˆÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙÙŠ Ù…Ø¬Ø§Ù„ ${subject}ØŸ`,
      options: [
        { text_ar: `Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙˆØ§Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø±Ø§Ø¬Ø¹Ø©`, is_correct: true },
        { text_ar: `Ø§Ù„Ø£Ø¯Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ·ÙˆÙŠØ±Ù‡`, is_correct: false },
        { text_ar: `Ø¨Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‡Ø¨Ø© Ø§Ù„ÙØ·Ø±ÙŠØ© ÙÙ‚Ø·`, is_correct: false },
        { text_ar: `Ø¨Ø²ÙŠØ§Ø¯Ø© Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø¹Ù…Ù„ Ø¯ÙˆÙ† ØªØ®Ø·ÙŠØ·`, is_correct: false },
      ]
    },
    {
      question: `Ù…Ø§ Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ ÙÙŠ ${subject}ØŸ`,
      options: [
        { text_ar: `ÙŠØ¹Ø²Ø² Ø§Ù„Ø¥Ù†ØªØ§Ø¬ÙŠØ© ÙˆÙŠØ­Ø³Ù† Ø¬ÙˆØ¯Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬`, is_correct: true },
        { text_ar: `Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ÙØ±Ø¯ÙŠ Ø£ÙØ¶Ù„ Ø¯Ø§Ø¦Ù…Ø§Ù‹`, is_correct: false },
        { text_ar: `Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù‡Ù…ÙŠØ© Ù„Ù„Ø¹Ù…Ù„ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ`, is_correct: false },
        { text_ar: `ÙŠØ¨Ø·Ø¦ Ø³ÙŠØ± Ø§Ù„Ø¹Ù…Ù„ ÙÙ‚Ø·`, is_correct: false },
      ]
    },
    {
      question: `Ù…Ø§ Ù‡Ùˆ Ø£Ø«Ø± ${subject} Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¤Ø³Ø³Ø©ØŸ`,
      options: [
        { text_ar: `ÙŠØ³Ø§Ù‡Ù… ÙÙŠ ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©`, is_correct: true },
        { text_ar: `Ù„ÙŠØ³ Ù„Ù‡ Ø£ÙŠ Ø£Ø«Ø± ÙŠØ°ÙƒØ±`, is_correct: false },
        { text_ar: `ÙŠØ²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙƒØ§Ù„ÙŠÙ ÙÙ‚Ø·`, is_correct: false },
        { text_ar: `ÙŠØ¹ÙŠÙ‚ Ø§Ù„ØªØ·ÙˆØ± Ø§Ù„Ù…Ø¤Ø³Ø³ÙŠ`, is_correct: false },
      ]
    }
  ];

  // Likert scale question templates
  const likertTemplates = [
    `Ø£Ø´Ø¹Ø± Ø¨Ø§Ù„Ø«Ù‚Ø© ÙÙŠ Ù‚Ø¯Ø±ØªÙŠ Ø¹Ù„Ù‰ ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¨Ø§Ø¯Ø¦ ${subject} ÙÙŠ Ø¹Ù…Ù„ÙŠ Ø§Ù„ÙŠÙˆÙ…ÙŠ`,
    `Ù„Ø¯ÙŠ ÙÙ‡Ù… ÙˆØ§Ø¶Ø­ Ù„Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙÙŠ ${subject}`,
    `Ø£Ø³ØªØ·ÙŠØ¹ Ø´Ø±Ø­ Ø£Ù‡Ù…ÙŠØ© ${subject} Ù„Ø²Ù…Ù„Ø§Ø¦ÙŠ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„`,
    `Ø£Ø·Ø¨Ù‚ Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ ${subject} Ø¨Ø´ÙƒÙ„ Ù…Ù†ØªØ¸Ù…`,
    `Ø£Ø³Ø¹Ù‰ Ù„ØªØ·ÙˆÙŠØ± Ù…Ù‡Ø§Ø±Ø§ØªÙŠ ÙÙŠ ${subject} Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø±`,
    `Ø£Ø³ØªØ·ÙŠØ¹ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ ${subject} Ø¨ÙØ¹Ø§Ù„ÙŠØ©`,
    `Ø£Ø´Ø§Ø±Ùƒ Ù…Ø¹Ø±ÙØªÙŠ ÙÙŠ ${subject} Ù…Ø¹ Ø£Ø¹Ø¶Ø§Ø¡ ÙØ±ÙŠÙ‚ÙŠ`,
    `Ø£ØªØ§Ø¨Ø¹ Ø£Ø­Ø¯Ø« Ø§Ù„ØªØ·ÙˆØ±Ø§Øª ÙÙŠ Ù…Ø¬Ø§Ù„ ${subject}`,
    `Ø£Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø¯ÙˆØ§Øª ÙˆØ§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø© ÙÙŠ ${subject}`,
    `Ø£Ø³Ø§Ù‡Ù… ÙÙŠ ØªØ­Ø³ÙŠÙ† Ø¹Ù…Ù„ÙŠØ§Øª ${subject} ÙÙŠ Ù…Ø¤Ø³Ø³ØªÙŠ`
  ];

  // Self-rating question templates
  const selfRatingTemplates = [
    `Ù‚ÙŠÙ‘Ù… Ù…Ø³ØªÙˆÙ‰ Ù…Ø¹Ø±ÙØªÙƒ Ø§Ù„Ù†Ø¸Ø±ÙŠØ© ÙÙŠ ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ ØªØ·Ø¨ÙŠÙ‚ ${subject} Ø¹Ù…Ù„ÙŠØ§Ù‹`,
    `Ù‚ÙŠÙ‘Ù… Ù…Ù‡Ø§Ø±Ø§ØªÙƒ ÙÙŠ Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ø­ÙˆÙ„ Ù…ÙˆØ¶ÙˆØ¹Ø§Øª ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù…Ø³ØªÙˆÙ‰ Ø®Ø¨Ø±ØªÙƒ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙÙŠ ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ† ÙÙŠ ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù…Ù‡Ø§Ø±Ø§ØªÙƒ Ø§Ù„Ù‚ÙŠØ§Ø¯ÙŠØ© ÙÙŠ Ù…Ø¬Ø§Ù„ ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± ÙÙŠ ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù…Ø³ØªÙˆÙ‰ Ø¥Ù†ØªØ§Ø¬ÙŠØªÙƒ ÙÙŠ Ù…Ù‡Ø§Ù… ${subject}`,
    `Ù‚ÙŠÙ‘Ù… Ù‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙŠÙ Ù…Ø¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ ${subject}`
  ];

  // Open text question templates
  const openTextTemplates = [
    `Ø§Ø´Ø±Ø­ Ø¨Ø§Ù„ØªÙØµÙŠÙ„ ÙƒÙŠÙ ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ† ${subject} ÙÙŠ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…Ù„`,
    `Ù…Ø§ Ù‡ÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª Ø§Ù„ØªÙŠ ÙˆØ§Ø¬Ù‡ØªÙ‡Ø§ ÙÙŠ ${subject} ÙˆÙƒÙŠÙ ØªØºÙ„Ø¨Øª Ø¹Ù„ÙŠÙ‡Ø§ØŸ`,
    `ØµÙ ØªØ¬Ø±Ø¨Ø© Ù†Ø§Ø¬Ø­Ø© Ù„Ùƒ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¨Ø§Ø¯Ø¦ ${subject}`,
    `Ù…Ø§ Ù‡ÙŠ Ø§Ù‚ØªØ±Ø§Ø­Ø§ØªÙƒ Ù„ØªØ·ÙˆÙŠØ± ${subject} ÙÙŠ Ø§Ù„Ù…Ø¤Ø³Ø³Ø©ØŸ`,
    `ÙƒÙŠÙ ØªØ±Ù‰ Ù…Ø³ØªÙ‚Ø¨Ù„ ${subject} ÙÙŠ Ø§Ù„Ø³Ù†ÙˆØ§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©ØŸ`,
    `Ù…Ø§ Ù‡ÙŠ Ø£Ù‡Ù… Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ ØªØ¹Ù„Ù…ØªÙ‡Ø§ Ù…Ù† Ø®Ø¨Ø±ØªÙƒ ÙÙŠ ${subject}ØŸ`,
    `ÙƒÙŠÙ ÙŠÙ…ÙƒÙ† Ø¯Ù…Ø¬ ${subject} Ù…Ø¹ Ù…Ø¬Ø§Ù„Ø§Øª Ø£Ø®Ø±Ù‰ Ù„ØªØ­Ù‚ÙŠÙ‚ Ù†ØªØ§Ø¦Ø¬ Ø£ÙØ¶Ù„ØŸ`,
    `Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù„ØªØ·ÙˆÙŠØ±Ù‡Ø§ ÙÙŠ ${subject}ØŸ`,
    `ØµÙ ÙƒÙŠÙ ÙŠÙ…ÙƒÙ† Ù‚ÙŠØ§Ø³ ÙØ¹Ø§Ù„ÙŠØ© ${subject} ÙÙŠ Ø§Ù„Ù…Ø¤Ø³Ø³Ø©`,
    `Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„ØªÙŠ ØªÙ‚Ø¯Ù…Ù‡Ø§ Ù„Ù„Ù…Ø¨ØªØ¯Ø¦ÙŠÙ† ÙÙŠ ${subject}ØŸ`
  ];

  // Track used indices to avoid repetition
  const usedMcq = new Set();
  const usedLikert = new Set();
  const usedSelfRating = new Set();
  const usedOpenText = new Set();
  
  // Generate questions strictly according to distribution
  let questionIndex = 0;
  
  for (const [type, count] of Object.entries(typeDistribution)) {
    for (let i = 0; i < count; i++) {
      const question = {
        id: `ai-${Date.now()}-${questionIndex}`,
        question_type: type,
        question_ar: '',
        question_en: '',
        skill_id: '',
        required: true,
        weight: 1.0,
        options: null,
        likert_labels: null,
        self_rating_config: null,
        assessment_metadata: null
      };
      
      if (type === 'mcq') {
        // Use different skills for variety if available
        let questionSubject = subject;
        if (skillsList.length > 1) {
          // Rotate through skills
          questionSubject = skillsList[questionIndex % skillsList.length];
        }
        
        // Get a random unused MCQ template
        let templateIndex = Math.floor(Math.random() * mcqTemplates.length);
        while (usedMcq.has(templateIndex) && usedMcq.size < mcqTemplates.length) {
          templateIndex = (templateIndex + 1) % mcqTemplates.length;
        }
        usedMcq.add(templateIndex);
        
        const template = mcqTemplates[templateIndex];
        question.question_ar = template.question.replace(subject, questionSubject);
        question.options = template.options.map((opt, idx) => ({
          value: String.fromCharCode(97 + idx), // a, b, c, d
          text_ar: opt.text_ar.replace(subject, questionSubject),
          text_en: '',
          is_correct: opt.is_correct,
          score: opt.is_correct ? 10 : 0
        }));
        
        // Shuffle options
        for (let j = question.options.length - 1; j > 0; j--) {
          const k = Math.floor(Math.random() * (j + 1));
          [question.options[j], question.options[k]] = [question.options[k], question.options[j]];
        }
        // Re-assign values after shuffle
        question.options.forEach((opt, idx) => {
          opt.value = String.fromCharCode(97 + idx);
        });
        
        // Add assessment metadata for MCQ
        question.assessment_metadata = {
          rationale: `Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© ØªÙ…Ø«Ù„ Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª ÙÙŠ Ù…Ø¬Ø§Ù„ ${questionSubject}`,
          common_errors: 'Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø© ØªÙ…Ø«Ù„ Ù…ÙØ§Ù‡ÙŠÙ… Ø®Ø§Ø·Ø¦Ø© Ø´Ø§Ø¦Ø¹Ø© Ø£Ùˆ ØªØ·Ø¨ÙŠÙ‚Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
          competency_measured: questionSubject,
          cognitive_level: level === 'beginner' ? 'knowledge' : level === 'intermediate' ? 'application' : 'analysis'
        };
        
      } else if (type === 'likert_scale') {
        // Use different skills for variety if available
        let questionSubject = subject;
        if (skillsList.length > 1) {
          questionSubject = skillsList[questionIndex % skillsList.length];
        }
        
        let templateIndex = Math.floor(Math.random() * likertTemplates.length);
        while (usedLikert.has(templateIndex) && usedLikert.size < likertTemplates.length) {
          templateIndex = (templateIndex + 1) % likertTemplates.length;
        }
        usedLikert.add(templateIndex);
        
        question.question_ar = likertTemplates[templateIndex].replace(subject, questionSubject);
        question.likert_labels = {
          min_label_ar: 'Ù„Ø§ Ø£ÙˆØ§ÙÙ‚ Ø¨Ø´Ø¯Ø©',
          min_label_en: 'Strongly Disagree',
          max_label_ar: 'Ø£ÙˆØ§ÙÙ‚ Ø¨Ø´Ø¯Ø©',
          max_label_en: 'Strongly Agree',
          scale: 5
        };
        
        // Add assessment metadata for Likert
        question.assessment_metadata = {
          competency_measured: `Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø© Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ© ÙÙŠ ${questionSubject}`,
          cognitive_level: 'self_assessment'
        };
        
      } else if (type === 'self_rating') {
        // Use different skills for variety if available
        let questionSubject = subject;
        if (skillsList.length > 1) {
          questionSubject = skillsList[questionIndex % skillsList.length];
        }
        
        let templateIndex = Math.floor(Math.random() * selfRatingTemplates.length);
        while (usedSelfRating.has(templateIndex) && usedSelfRating.size < selfRatingTemplates.length) {
          templateIndex = (templateIndex + 1) % selfRatingTemplates.length;
        }
        usedSelfRating.add(templateIndex);
        
        question.question_ar = selfRatingTemplates[templateIndex].replace(subject, questionSubject);
        question.self_rating_config = {
          min: 1, max: 10,
          labels: [
            { value: 1, ar: 'Ù…Ø¨ØªØ¯Ø¦', en: 'Beginner' },
            { value: 5, ar: 'Ù…ØªÙˆØ³Ø·', en: 'Intermediate' },
            { value: 10, ar: 'Ø®Ø¨ÙŠØ±', en: 'Expert' }
          ]
        };
        
        // Add assessment metadata for Self-Rating
        question.assessment_metadata = {
          competency_measured: `Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙƒÙØ§Ø¡Ø© ÙÙŠ ${questionSubject}`,
          cognitive_level: 'self_assessment'
        };
        
      } else if (type === 'open_text') {
        // Use different skills for variety if available
        let questionSubject = subject;
        if (skillsList.length > 1) {
          questionSubject = skillsList[questionIndex % skillsList.length];
        }
        
        let templateIndex = Math.floor(Math.random() * openTextTemplates.length);
        while (usedOpenText.has(templateIndex) && usedOpenText.size < openTextTemplates.length) {
          templateIndex = (templateIndex + 1) % openTextTemplates.length;
        }
        usedOpenText.add(templateIndex);
        
        question.question_ar = openTextTemplates[templateIndex].replace(subject, questionSubject);
        
        // Add assessment metadata for Open Text
        question.assessment_metadata = {
          rubric: [
            { criterion: 'Ø§Ù„ÙˆØ¶ÙˆØ­ ÙˆØ§Ù„ØªÙ†Ø¸ÙŠÙ…', points: 3, description: 'Ø¹Ø±Ø¶ ÙˆØ§Ø¶Ø­ ÙˆÙ…Ù†Ø¸Ù… Ù„Ù„Ø£ÙÙƒØ§Ø±' },
            { criterion: 'Ø¹Ù…Ù‚ Ø§Ù„ØªØ­Ù„ÙŠÙ„', points: 4, description: 'ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ Ù„Ù„Ù…ÙˆØ¶ÙˆØ¹ Ù…Ø¹ Ø£Ù…Ø«Ù„Ø©' },
            { criterion: 'Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ', points: 3, description: 'Ø±Ø¨Ø· Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ' }
          ],
          competency_measured: `Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„Ù†Ù‚Ø¯ÙŠ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„ ÙÙŠ ${questionSubject}`,
          cognitive_level: level === 'advanced' ? 'evaluation' : 'analysis'
        };
      }
      
      questions.push(question);
      questionIndex++;
    }
  }
  
  console.log(`Fallback generated ${questions.length} questions (expected ${numQuestions})`);
  return questions;
}

// Get all tests
router.get('/', authenticate, isTrainingOfficer, async (req, res) => {
  try {
    const { domain_id, status, page = 1, limit = 20 } = req.query;
    const offset = (page - 1) * limit;
    
    let query = `
      SELECT t.*,
             td.name_ar as domain_name_ar,
             td.name_en as domain_name_en,
             td.color as domain_color,
             u.name_ar as created_by_name_ar,
             u.name_en as created_by_name_en,
             (SELECT COUNT(*) FROM questions WHERE test_id = t.id) as questions_count,
             (SELECT COUNT(*) FROM test_assignments WHERE test_id = t.id) as assignments_count,
             (SELECT COUNT(*) FROM test_assignments WHERE test_id = t.id AND status = 'completed') as completed_count
      FROM tests t
      LEFT JOIN training_domains td ON t.domain_id = td.id
      LEFT JOIN users u ON t.created_by = u.id
      WHERE 1=1
    `;
    const params = [];
    let paramCount = 0;
    
    if (domain_id) {
      paramCount++;
      query += ` AND t.domain_id = $${paramCount}`;
      params.push(domain_id);
    }
    
    if (status) {
      paramCount++;
      query += ` AND t.status = $${paramCount}`;
      params.push(status);
    }
    
    query += ` ORDER BY t.created_at DESC LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;
    params.push(limit, offset);
    
    const result = await db.query(query, params);
    
    res.json({
      tests: result.rows,
      page: parseInt(page),
      limit: parseInt(limit)
    });
  } catch (error) {
    console.error('Get tests error:', error);
    res.status(500).json({ error: 'Failed to get tests' });
  }
});

// Get single test with questions
router.get('/:id', authenticate, async (req, res) => {
  try {
    const testResult = await db.query(`
      SELECT t.*,
             td.name_ar as domain_name_ar,
             td.name_en as domain_name_en,
             td.color as domain_color,
             u.name_ar as created_by_name_ar,
             u.name_en as created_by_name_en
      FROM tests t
      LEFT JOIN training_domains td ON t.domain_id = td.id
      LEFT JOIN users u ON t.created_by = u.id
      WHERE t.id = $1
    `, [req.params.id]);
    
    if (testResult.rows.length === 0) {
      return res.status(404).json({ error: 'Test not found' });
    }
    
    const questionsResult = await db.query(`
      SELECT q.*,
             s.name_ar as skill_name_ar,
             s.name_en as skill_name_en
      FROM questions q
      LEFT JOIN skills s ON q.skill_id = s.id
      WHERE q.test_id = $1
      ORDER BY q.order_index
    `, [req.params.id]);
    
    // Get target skills
    const targetSkillsResult = await db.query(`
      SELECT s.id, s.name_ar, s.name_en, s.description_ar, s.description_en
      FROM test_skills ts
      JOIN skills s ON ts.skill_id = s.id
      WHERE ts.test_id = $1
      ORDER BY s.name_ar
    `, [req.params.id]);
    
    res.json({
      ...testResult.rows[0],
      questions: questionsResult.rows,
      target_skills: targetSkillsResult.rows
    });
  } catch (error) {
    console.error('Get test error:', error);
    res.status(500).json({ error: 'Failed to get test' });
  }
});

// Create test
router.post('/', authenticate, isTrainingOfficer, [
  body('domain_id').isUUID(),
  body('title_ar').notEmpty(),
  body('title_en').optional()
], async (req, res) => {
  const client = await db.getClient();
  
  try {
    await client.query('BEGIN');
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    const { 
      domain_id, title_ar, title_en, description_ar, description_en,
      instructions_ar, instructions_en, duration_minutes, passing_score,
      is_timed, is_randomized, show_results_immediately, confidentiality_level,
      start_date, end_date, target_skill_ids
    } = req.body;
    
    const result = await client.query(`
      INSERT INTO tests (
        domain_id, title_ar, title_en, description_ar, description_en,
        instructions_ar, instructions_en, duration_minutes, passing_score,
        is_timed, is_randomized, show_results_immediately, confidentiality_level,
        start_date, end_date, created_by
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      RETURNING *
    `, [
      domain_id, title_ar, title_en, description_ar, description_en,
      instructions_ar, instructions_en, duration_minutes, passing_score,
      is_timed || false, is_randomized || false, show_results_immediately !== false, 
      confidentiality_level || 'standard', start_date, end_date, req.user.id
    ]);
    
    const testId = result.rows[0].id;
    
    // Save target skills if provided
    if (target_skill_ids && Array.isArray(target_skill_ids) && target_skill_ids.length > 0) {
      for (const skillId of target_skill_ids) {
        await client.query(
          'INSERT INTO test_skills (test_id, skill_id) VALUES ($1, $2) ON CONFLICT DO NOTHING',
          [testId, skillId]
        );
      }
    }
    
    await client.query('COMMIT');
    res.status(201).json(result.rows[0]);
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Create test error:', error);
    res.status(500).json({ error: 'Failed to create test' });
  } finally {
    client.release();
  }
});

// Update test
router.put('/:id', authenticate, isTrainingOfficer, async (req, res) => {
  const client = await db.getClient();
  
  try {
    await client.query('BEGIN');
    
    const { 
      title_ar, title_en, description_ar, description_en,
      instructions_ar, instructions_en, duration_minutes, passing_score,
      is_timed, is_randomized, show_results_immediately, confidentiality_level,
      start_date, end_date, status, target_skill_ids
    } = req.body;
    
    const result = await client.query(`
      UPDATE tests
      SET title_ar = COALESCE($1, title_ar),
          title_en = COALESCE($2, title_en),
          description_ar = COALESCE($3, description_ar),
          description_en = COALESCE($4, description_en),
          instructions_ar = COALESCE($5, instructions_ar),
          instructions_en = COALESCE($6, instructions_en),
          duration_minutes = COALESCE($7, duration_minutes),
          passing_score = COALESCE($8, passing_score),
          is_timed = COALESCE($9, is_timed),
          is_randomized = COALESCE($10, is_randomized),
          show_results_immediately = COALESCE($11, show_results_immediately),
          confidentiality_level = COALESCE($12, confidentiality_level),
          start_date = COALESCE($13, start_date),
          end_date = COALESCE($14, end_date),
          status = COALESCE($15, status)
      WHERE id = $16
      RETURNING *
    `, [
      title_ar, title_en, description_ar, description_en,
      instructions_ar, instructions_en, duration_minutes, passing_score,
      is_timed, is_randomized, show_results_immediately, confidentiality_level,
      start_date, end_date, status, req.params.id
    ]);
    
    if (result.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Test not found' });
    }
    
    // Update target skills if provided
    if (target_skill_ids !== undefined) {
      // Delete existing relationships
      await client.query('DELETE FROM test_skills WHERE test_id = $1', [req.params.id]);
      
      // Insert new relationships
      if (Array.isArray(target_skill_ids) && target_skill_ids.length > 0) {
        for (const skillId of target_skill_ids) {
          await client.query(
            'INSERT INTO test_skills (test_id, skill_id) VALUES ($1, $2) ON CONFLICT DO NOTHING',
            [req.params.id, skillId]
          );
        }
      }
    }
    
    await client.query('COMMIT');
    res.json(result.rows[0]);
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Update test error:', error);
    res.status(500).json({ error: 'Failed to update test' });
  } finally {
    client.release();
  }
});

// Publish test
router.post('/:id/publish', authenticate, isTrainingOfficer, async (req, res) => {
  try {
    // Check if test has questions
    const questionCheck = await db.query('SELECT id FROM questions WHERE test_id = $1 LIMIT 1', [req.params.id]);
    if (questionCheck.rows.length === 0) {
      return res.status(400).json({ error: 'Cannot publish test without questions' });
    }
    
    const result = await db.query(`
      UPDATE tests SET status = 'published' WHERE id = $1 AND status = 'draft' RETURNING *
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.status(400).json({ error: 'Test not found or already published' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Publish test error:', error);
    res.status(500).json({ error: 'Failed to publish test' });
  }
});

// Close test
router.post('/:id/close', authenticate, isTrainingOfficer, async (req, res) => {
  try {
    const result = await db.query(`
      UPDATE tests SET status = 'closed' WHERE id = $1 RETURNING *
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Test not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Close test error:', error);
    res.status(500).json({ error: 'Failed to close test' });
  }
});

// Delete test
router.delete('/:id', authenticate, isTrainingOfficer, async (req, res) => {
  try {
    const result = await db.query('DELETE FROM tests WHERE id = $1 RETURNING id', [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Test not found' });
    }
    
    res.json({ message: 'Test deleted successfully' });
  } catch (error) {
    console.error('Delete test error:', error);
    res.status(500).json({ error: 'Failed to delete test' });
  }
});

// Duplicate test
router.post('/:id/duplicate', authenticate, isTrainingOfficer, async (req, res) => {
  const client = await db.getClient();
  
  try {
    await client.query('BEGIN');
    
    // Get original test
    const testResult = await client.query('SELECT * FROM tests WHERE id = $1', [req.params.id]);
    if (testResult.rows.length === 0) {
      return res.status(404).json({ error: 'Test not found' });
    }
    
    const original = testResult.rows[0];
    
    // Create duplicate test
    const newTest = await client.query(`
      INSERT INTO tests (
        domain_id, title_ar, title_en, description_ar, description_en,
        instructions_ar, instructions_en, duration_minutes, passing_score,
        is_timed, is_randomized, show_results_immediately, confidentiality_level,
        status, created_by
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'draft', $14)
      RETURNING *
    `, [
      original.domain_id, 
      original.title_ar + ' (Ù†Ø³Ø®Ø©)', 
      original.title_en + ' (Copy)',
      original.description_ar, original.description_en,
      original.instructions_ar, original.instructions_en,
      original.duration_minutes, original.passing_score,
      original.is_timed, original.is_randomized, original.show_results_immediately,
      original.confidentiality_level, req.user.id
    ]);
    
    // Copy questions
    const questions = await client.query('SELECT * FROM questions WHERE test_id = $1', [req.params.id]);
    for (const q of questions.rows) {
      await client.query(`
        INSERT INTO questions (test_id, skill_id, question_type, question_ar, question_en, 
                              options, likert_labels, self_rating_config, required, weight, order_index)
        VALUES ($1, $2, $3, $4, $5, $6::jsonb, $7::jsonb, $8::jsonb, $9, $10, $11)
      `, [
        newTest.rows[0].id, q.skill_id, q.question_type, q.question_ar, q.question_en,
        JSON.stringify(q.options), 
        q.likert_labels ? JSON.stringify(q.likert_labels) : null, 
        q.self_rating_config ? JSON.stringify(q.self_rating_config) : null, 
        q.required, q.weight, q.order_index
      ]);
    }
    
    await client.query('COMMIT');
    res.status(201).json(newTest.rows[0]);
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Duplicate test error:', error);
    res.status(500).json({ error: 'Failed to duplicate test' });
  } finally {
    client.release();
  }
});

module.exports = router;

